import re
from datetime import datetime


def extraer_folio(texto):
    lines = texto.splitlines()
    for i, line in enumerate(lines):
        if re.search(r"Folio\s*:", line, re.IGNORECASE):
            print(f"\nüîé L√≠nea con 'Folio:': {repr(line)}")
            for offset in range(1, 4):
                if i - offset >= 0:
                    anterior = lines[i - offset].strip()
                    print(f"üëÅ L√≠nea anterior ({offset}): {repr(anterior)}")
                    cleaned = re.sub(r"[^\d]", "", anterior)
                    print(f"üßº Limpiado: {repr(cleaned)}")
                    if cleaned.isdigit():
                        print(f"‚úÖ Detectado como folio: {cleaned}")
                        return cleaned
            raise ValueError("‚ùå Se encontr√≥ 'Folio:' pero no hab√≠a n√∫mero v√°lido en las l√≠neas anteriores.")
    raise ValueError("‚ùå No se encontr√≥ 'Folio:' en el texto OCR.")



def extraer_uuid(texto):
    """
    Busca el primer UUID con el formato est√°ndar (36 caracteres) en el texto.
    """
    match = re.search(r"\b[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}\b", texto)
    if not match:
        raise ValueError("‚ùå No se encontr√≥ un UUID v√°lido en el texto OCR.")
    return match.group(0)


def extraer_fecha_emision(texto):
    """
    Busca una fecha con formato ISO 8601, como 2025-01-15T09:28:22
    """
    match = re.search(r"(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})", texto)
    if not match:
        raise ValueError("‚ùå No se encontr√≥ la fecha de emisi√≥n en el texto OCR.")
    return datetime.fromisoformat(match.group(1))


def extraer_total(texto: str) -> float:
    """
    Extrae el TOTAL de una factura desde el texto OCR.
    
    L√≥gica:
    - Caso 1: Buscar l√≠nea que diga exactamente 'Total' y tomar el monto mayor en las siguientes l√≠neas.
    - Caso 2: Buscar l√≠nea que diga 'Total:' en formato clave-valor (Total: $X,XXX.XX).
    - Caso 3: Fallback por 'Bueno por: $X,XXX.XX' para facturas tipo pagar√©.
    """
    lines = texto.splitlines()

    # Caso 1: L√≠nea que diga solo "Total" y revisar siguientes l√≠neas
    for i, line in enumerate(lines):
        if re.fullmatch(r"\bTotal\b", line.strip(), re.IGNORECASE):
            max_total = None
            for j in range(1, 10):  # buscar hasta 10 l√≠neas despu√©s
                if i + j < len(lines):
                    candidate = lines[i + j].strip()
                    matches = re.findall(r"\$?\s*([\d,]+\.\d{2})", candidate)
                    for match in matches:
                        value = float(match.replace(",", ""))
                        if max_total is None or value > max_total:
                            max_total = value
            if max_total is not None:
                return max_total

    # Caso 2: Total en la misma l√≠nea tipo "Total: $1234.56"

def extraer_total(texto: str) -> float:
    """
    Extrae el TOTAL (no el subtotal) de una factura.
    - Busca todas las ocurrencias v√°lidas de la palabra TOTAL (excluyendo SUBTOTAL).
    - Explora hasta 8 l√≠neas posteriores por cada ocurrencia.
    - Devuelve el monto m√°s alto entre todos los candidatos encontrados.
    """
    lines = texto.splitlines()
    total_candidates = []

    # Paso 1: Buscar todas las l√≠neas con "TOTAL" pero no "SUBTOTAL"
    for i, line in enumerate(lines):
        if re.search(r"\bTOTAL\b", line, re.IGNORECASE) and not re.search(r"SUBTOTAL", line, re.IGNORECASE):
            for j in range(1, 9):
                if i + j < len(lines):
                    candidate = lines[i + j].strip()
                    match = re.search(r"\$?\s*([\d,]+\.\d{2})", candidate)
                    if match:
                        value = float(match.group(1).replace(",", ""))
                        total_candidates.append(value)

    if total_candidates:
        return max(total_candidates)

    # Paso 2: Fallback directo
    match = re.search(r"(?<!SUB)TOTAL\s*:\s*\$?\s*([\d,]+\.\d{2})", texto, re.IGNORECASE)
    if match:
        return float(match.group(1).replace(",", ""))

    # Paso 3: Fallback por "IMPORTE EN LETRA"
    match = re.search(r"IMPORTE EN LETRA.*?\n.*?\n.*?([\d,]+\.\d{2})", texto, re.IGNORECASE | re.DOTALL)
    if match:
        return float(match.group(1).replace(",", ""))

    # Paso 4: Fallback total ‚Äî mayor n√∫mero del texto
    all_matches = re.findall(r"\$?\s*([\d,]+\.\d{2})", texto)
    if all_matches:
        values = [float(x.replace(",", "")) for x in all_matches]
        return max(values)

    raise ValueError("‚ùå No se encontr√≥ el total en el texto OCR.")




